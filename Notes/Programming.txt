Printf format specifiers:
How do you declare an array of function pointers? void (*fn_arr[arr_size])(void *args);
char val = -3; printf("%hu\n", val);
Here, in printf, replace val with the value. There are three different cases here on what to replace val with.
- If val is signed and the value assigned is negative, then the negative number. (Add the case for out of range negative numbers.)
- If val is unsigned and the value assigned is negative, then the positive value of the 2's complement of the negative.
- If value is positive and within the positive range of the datatype, then the actual value.
- If value is positive but outside the positive range of the type, then find out what value val would have and put that.
char - %c, signed char - %hhi, %hhd; unsigned char - %hhu, signed short - %hi, %hd; unsigned short - %hu, signed int - %i, %d; unsigned int - %u, signed long - %li, %ld; unsigned long - %lu, signed long long - %lli, %lld; unsigned long long - %llu, short hex - %hx, single byte hex - %hhx.
How do you print a turning line on a text console? For instance, the in-place turning line on "Waiting for SP...\"?
unsigned c = 0x2d5c7c2f (These are the ascii's for \,|,/,-, not necessarily in that order, just lookup an ascii table.)
To print them in turn, change MSB into LSB for each iteration: printf ("%c\b", c = c << 8 | c >> 24);
To align a value to the closest lower 4K, AND it with ~FFF. To align it to the closest higher 4K, do the same and add 0x1000. So in conclusion, to align to lower 4K, value & ~(0x1000 - 1). Memcached approach: val += alignment - (val % alignment)
How do you find the offset of a field in a struct? &(((struct node*)0)->Field) gives you the offset.
********
| Unix |
********
Regex:
ls * => List everything.
ls hello[1234] => List hello1, hello2, hello3 and hello4 if they exist.
ls hello[1-4] => Same as above.
ls 'hello*' or ls hello\* => Don't interpret the wildcard.
alias ll "ls -l"
Find a file in Unix: find . -name E6413X3.EFI
Find the header file needed to use a library function (say, exit()): man exit -s 3. See man man for more info. 2 for system call and 3 for C library.
======================================================
Commit these to your memory:
Dictionary operations: Insert(D,x), Search(D,k), Delete(D,x). Optional operations: Min/Max(D), Predecessor/Successor(D,x). Min/Max are priority queue operations.
Priority Queue: Insert(Q,x), Min/Max(Q), DeleteMin/Max(Q)
======================================================
***OpenSource Projects:
libsvm (C++), memcached (small project, C, dive in!)
libevent (C) - Developed by Niels Provos, lighttpd (small, C)
HAProxy - The fastest load balancer. Written in C.
======================================================
C++:
How do you create a class and still prohibit people from creating instance of the class? Answer - By making the class constructor protected. This lets derived classes inherit this class and create instances of the derived class, while still being able to initialize the base portion of the derived object.
l-values are objects that have a defined memory address and persist beyond a single expression. r-values are temporary values, do not have a defined memory address and only have expression scope.
You can bind a const reference to an r-value. You cannot bind a non-const reference to an r-value. You can however, to an l-value. See example below:
int& val = 5; // Doesn't work. const int& val = 5; // Works.
If you need a fixed array of unique items:
std::array < std::unordered_set<int>, 2 > arr = { std::unordered_set<int> {1,2,2,3}, std::unordered_set<int> {2,2,7,5,5} };
arr[1].insert(13);

# Snippet 1:
int main() {
  unordered_map <int, vector<int>> umap;

  umap.insert({5, {4,7,1,2}}); // If you don't specify the type of second parameter like in the above unordered_set example, it defaults to vector.

  // Use auto it = umap.find(5); to reduce verbosity.
  // umap.find() returns an r-value. So if you need a reference, you need to use a const reference.
  unordered_map <int, vector<int>>::iterator it = umap.find(5);

  if (it != umap.end()) {
    for (const int item : it->second)
      cout << item << ' ';
  }
}

# Snippet 2:
int main () {
  unordered_map<int, vector<int>> adj;

  // Note that you can only resort to subscript-based access when the map is not a const object!
  // const unordered_map<int, vector<int>>& adj_const = adj;
  // const vector<int> vec = adj_const[4] leads to a build error. Replace adj_const with the non-const adj and things work.
  // See snippet 5 for an example.
  adj[4].push_back(4);
  adj[4].push_back(5);
  adj[4].push_back(6);
  adj[4].push_back(7);
  
  adj[2].push_back(12);
  adj[2].push_back(9);
  adj[2].push_back(7);

  adj[7].push_back(0);
  adj[7].push_back(2);

  adj[3].push_back(75);
  adj[3].push_back(1);
  adj[3].push_back(1);

  adj[11].push_back(3);
  
  // Shorter way of doing this:
  adj[4] = {4,5,6,7};
  adj[2] = {12,9,7};
  adj[7] = {0,2};
  adj[3] = {75,1,1};
  adj[11] = {3};

  for (const auto& it : adj) {
    cout << it.first << ": ";
    for (const auto& item : it.second) // Iterator in the previous snippet is a pointer. So the '->' operator. Here use the '.' operator.
      cout << item << ' ';
    cout << endl;
  }
}

Output:
3: 75 1 1
7: 0 2
11: 3
4: 4 5 6 7
2: 12 9 7

# Snippet 3:
To initialize a dynamic struct:
struct Node {
  int data;
  struct Node *next;
};

Node *newnode = new Node {4, nullptr};
int *ptr = new int[4] {1,2,3,4}; // Size parameter '4' is mandatory. If more items provided in the initializer list, you get a build error. If less items, then rest set to zero.

# Snippet 4: To iterate over an unordered_map and remove all elements as you iterate.
int main() {
  unordered_map<int, int> umap;

  for (int i = 1; i <= 10; i++)
    umap[i] = i * 10;

  for (auto it = umap.begin(); it != umap.end();) {
    cout << it->first << ": " << it->second << endl;

    // Note that you pass 'it' as parameter to the erase function and not it->first.
    // Set 'it' to the item immediately following the erased item.
    it = umap.erase(it);
  }
}

# Snippet 5
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int main () {
  unordered_map<int, vector<int>> umap;
  
  umap[4] = {40, 50};
  umap[5] = {50, 60};
  
  for (const auto& item : umap[4])
    cout << item << ' ';
}

# Snippet 6
#include <queue>
priority_queue<int> pq; // You get a max-heap by default. See below to get a min-heap.
pq.push(data);
pq.pop();
cout << pq.top()

#include <queue>
#include <functional> // Header for std::greater.
priority_queue<int, vector<int>, greater<int>> pq; // Gives you a min heap.
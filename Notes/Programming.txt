Printf format specifiers:
How do you declare an array of function pointers? void (*fn_arr[arr_size])(void *args);
char - %c, signed char - %hhi, %hhd; unsigned char - %hhu, signed short - %hi, %hd; unsigned short - %hu, signed int - %i, %d; unsigned int - %u, signed long - %li, %ld; unsigned long - %lu, signed long long - %lli, %lld; unsigned long long - %llu, short hex - %hx, single byte hex - %hhx.
How do you print a turning line on a text console? For instance, the in-place turning line on "Waiting for SP...\"?
unsigned c = 0x2d5c7c2f (These are the ascii's for \,|,/,-, not necessarily in that order, just lookup an ascii table.)
To print them in turn, change MSB into LSB for each iteration: printf ("%c\b", c = c << 8 | c >> 24);
To align a value to the closest lower 4K, AND it with ~FFF. To align it to the closest higher 4K, do the same and add 0x1000. So in conclusion, to align to lower 4K, value & ~(0x1000 - 1). Memcached approach: val += alignment - (val % alignment)
How do you find the offset of a field in a struct? &(((struct node*)0)->Field) gives you the offset.
********
| Unix |
********
Regex:
ls * => List everything.
ls hello[1234] => List hello1, hello2, hello3 and hello4 if they exist.
ls hello[1-4] => Same as above.
ls 'hello*' or ls hello\* => Don't interpret the wildcard.
alias ll "ls -l"
Find a file in Unix: find . -name E6413X3.EFI
Find the header file needed to use a library function (say, exit()): man exit -s 3. See man man for more info. 2 for system call and 3 for libc.
======================================================
Commit these to your memory:
Dictionary operations: Insert(D,x), Search(D,k), Delete(D,x). Optional operations: Min/Max(D), Predecessor/Successor(D,x). Min/Max are priority queue operations.
Priority Queue: Insert(Q,x), Min/Max(Q), DeleteMin/Max(Q)
======================================================
***OpenSource Projects:
http://preshing.com
https://github.com/fffaraz/awesome-cpp
OpenSource: TinyVM, libcds, Ceph
======================================================
C++ warmups:
How do you create a class and still prohibit people from creating instance of the class? Answer - By making the class constructor protected. This lets derived classes inherit this class and create instances of the derived class, while still being able to initialize the base portion of the derived object.
You can bind a const reference to an r-value. You cannot bind a non-const reference to an r-value. int& val = 5; // No. const int& val = 5; // Yes.
If you need a fixed array of unique items:
std::array < std::unordered_set<int>, 2 > arr = { std::unordered_set<int> {1,2,2,3}, std::unordered_set<int> {2,2,7,5,5} };
arr[1].insert(13);

# Snippet 1:
int main() {
  unordered_map <int, vector<int>> umap;

  umap.insert({5, {4,7,1,2}}); // If you don't specify the type of second parameter like in the above unordered_set example, it defaults to vector.
  umap[5] = {4,7,1,2}; // alternative to the above statement.

  unordered_map <int, vector<int>>::iterator it = umap.find(5); // Use auto it = umap.find(5); to reduce verbosity.

  if (it != umap.end()) {
    for (const int item : it->second)
      cout << item << ' ';
  }
}

# Snippet 2:
int main () {
  unordered_map<int, vector<int>> adj;

  // Note that you can only resort to subscript-based access when the map is not a const object!
  // const unordered_map<int, vector<int>>& adj_const = adj;
  // const vector<int> vec = adj_const[4] leads to a build error. Replace adj_const with the non-const adj and things work.
  // See snippet 5 for an example.
  adj[4].push_back(4);
  adj[4].push_back(5);
  adj[4].push_back(6);
  adj[4].push_back(7);

  adj[2].push_back(12);
  adj[2].push_back(9);
  adj[2].push_back(7);

  adj[7].push_back(0);
  adj[7].push_back(2);

  adj[3].push_back(75);
  adj[3].push_back(1);
  adj[3].push_back(1);

  adj[11].push_back(3);
  
  // Shorter way of doing this:
  adj[4] = {4,5,6,7};
  adj[2] = {12,9,7};
  adj[7] = {0,2};
  adj[3] = {75,1,1};
  adj[11] = {3};

  for (const auto& it : adj) {
    cout << it.first << ": ";
    for (const auto& item : it.second) // Iterator in the previous snippet is a pointer. So the '->' operator. Here use the '.' operator.
      cout << item << ' ';
    cout << endl;
  }
}

Output:
3: 75 1 1
7: 0 2
11: 3
4: 4 5 6 7
2: 12 9 7

# Snippet 3:
To initialize a dynamic struct:
struct Node {
  int data;
  Node *next;
};

Node *newnode = new Node {4, nullptr};
int *ptr = new int[4] {1,2,3,4}; // Size parameter '4' is mandatory. If more items provided in the initializer list, you get a build error. If less items, then rest set to zero.

# Snippet 4: To iterate over an unordered_map and remove all elements as you iterate.
int main() {
  unordered_map<int, int> umap;

  for (int i = 1; i <= 10; i++)
    umap[i] = i * 10;

  for (auto it = umap.begin(); it != umap.end();) { // Note: const auto it will fail. You need non-const.
    cout << it->first << ": " << it->second << endl;

    // Note that you pass 'it' as parameter to the erase function and not it->first.
    // Set 'it' to the item immediately following the erased item.
    it = umap.erase(it);
  }
}

# Snippet 5
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int main () {
  unordered_map<int, vector<int>> umap;
  
  umap[4] = {40, 50};
  umap[5] = {50, 60};
  
  for (const auto& item : umap[4])
    cout << item << ' ';
}

# Snippet 6
#include <queue>
priority_queue<int> pq; // You get a max-heap by default. See below to get a min-heap.
pq.push(data);
pq.pop();
cout << pq.top()

#include <queue>
#include <functional> // Header for std::greater.
priority_queue<int, vector<int>, greater<int>> pq; // Gives you a min heap.

#Snippet 7
# Initialize a two dimensional vector of size 5 x 5 to zeroes.
vector<vector<int>> tbl;

for (int i = 0; i < 5; i++) {
  tbl.push_back({0});
	
	for (int j = 0; j < 4; j++) {
	  tbl[i].push_back(0);
	}
}
l-values are objects that have a defined memory address and persist beyond a single expression. r-values are temporary values, do not have a defined memory address and only have expression scope.
Printf format specifiers:
%8.2f --> Print upto 2 decimal number precision; print 8 characters total, including the fraction.
%20s  --> Print a string that is right justified to 20 chars.
%-20s --> Print a string that is left justified to 20 chars.
%08x  --> Print a hex with eight nibbles. Pad with leading zeroes if necessary.
How do you declare an array of function pointers? void (*fn_arr[arr_size])(void *args);
char val = -3; printf("%hu\n", val);
Here, in printf, replace val with the value. There are three different cases here on what to replace val with.
- If val is signed and the value assigned is negative, then the negative number. (Add the case for out of range negative numbers.)
- If val is unsigned and the value assigned is negative, then the positive value of the 2's complement of the negative.
- If value is positive and within the positive range of the datatype, then the actual value.
- If value is positive but outside the positive range of the type, then find out what value val would have and put that.
char - %c, signed char - %hhi, %hhd; unsigned char - %hhu, signed short - %hi, %hd; unsigned short - %hu, signed int - %i, %d; unsigned int - %u, signed long - %li, %ld; unsigned long - %lu, signed long long - %lli, %lld; unsigned long long - %llu, short hex - %hx, single byte hex - %hhx.
How do you print a turning line on a text console? For instance, the in-place turning line on "Waiting for SP...\"?
unsigned c = 0x2d5c7c2f (These are the ascii's for \,|,/,-, not necessarily in that order, just lookup an ascii table.)
To print them in turn, change MSB into LSB for each iteration: printf ("%c\b", c = c << 8 | c >> 24);
To align a value to the closest lower 4K, AND it with ~FFF. To align it to the closest higher 4K, do the same and add 0x1000. So in conclusion, to align to lower 4K, value & ~(0x1000 - 1). Memcached approach: val += alignment - (val % alignment)
How do you find the offset of a field in a struct? &(((struct node*)0)->Field) gives you the offset.
********
| Unix |
********

#include <iostream>
#include <array>
#include <unordered_set>
using namespace std;

int main() {
  array< unordered_set<int>, 5> arr { unordered_set<int>{2,3,4,5,6},
                                      unordered_set<int>{2,2,3,3,3,4,4}
                                    };

  for (const auto& uset : arr) {
    for (const auto& item : uset)
      cout << item << ' ';
    cout << endl;
  }

  return 0;
}



Regex:
ls * => List everything.
ls hello[1234] => List hello1, hello2, hello3 and hello4 if they exist.
ls hello[1-4] => Same as above.
ls 'hello*' or ls hello\* => Don't interpret the wildcard.
alias ll "ls -l"
Find a file in Unix: find . -name E6413X3.EFI
Find the header file needed to use a library function (say, exit()): man exit -s 3. See man man for more info. 2 for system call and 3 for C library.
======================================================
***OpenSource Projects:
libsvm (C++), memcached (small project, C, dive in!)
libevent (C) - Developed by Niels Provos, lighttpd (small, C)
HAProxy - The fastest load balancer. Written in C.
======================================================
C++:
How do you create a class and still prohibit people from creating instance of the class? Answer - By making the class constructor protected. This lets derived classes inherit this class and create instances of the derived class, while still being able to initialize the base portion of the derived object.
If you need a fixed array of unique items:
std::array < std::unordered_set<int>, 2 > arr = { std::unordered_set<int> {1,2,2,3}, std::unordered_set<int> {2,2,7,5,5} };
arr[1].insert(13);

# Snippet 1:
int main() {
  unordered_map <int, vector<int>> umap;

  umap.insert({5, {4,7,1,2}}); // If you don't specify the type of second parameter like in the above unordered_set example, it defaults to vector.

  unordered_map <int, vector<int>>::iterator it = umap.find(5); // Use auto it = umap.find(5); to reduce verbosity.

  if (it != umap.end()) {
    for (const int item : it->second)
      cout << item << ' ';
  }

  return 0;
}

# Snippet 2:
int main () {
  unordered_map<int, vector<int>> adj;

  adj[4].push_back(4);
  adj[4].push_back(5);
  adj[4].push_back(6);
  adj[4].push_back(7);

  adj[2].push_back(12);
  adj[2].push_back(9);
  adj[2].push_back(7);

  adj[7].push_back(0);
  adj[7].push_back(2);

  adj[3].push_back(75);
  adj[3].push_back(1);
  adj[3].push_back(1);

  adj[11].push_back(3);

  for (const auto& it : adj) {
    cout << it.first << ": ";
    for (const auto& item : it.second) // Iterator in the previous example is a pointer. So the '->' operator. Here use the '.' operator.
      cout << item << ' ';
    cout << endl;
  }

  return 0;
}

Output:
3: 75 1 1
7: 0 2
11: 3
4: 4 5 6 7
2: 12 9 7

# Snippet 3:
To initialize a dynamic struct:
typedef struct {
  int data;
  struct node *next;
} Node;

Node *newnode = new Node {4, nullptr};
int *ptr = new int[4] {1,2,3,4}; // Size parameter '4' is mandatory. If more items provided in the initializer list, you get a build error. If less items, then rest set to zero.

# Snippet 4: To iterate over an unordered_map and remove all elements as you iterate.
int main() {
  unordered_map<int, int> umap;

  for (int i = 1; i <= 10; i++)
    umap[i] = i * 10;

  for (auto it = umap.begin(); it != umap.end();) {
    cout << it->first << ": " << it->second << endl;

    it = umap.erase(it); // Set 'it' to the item immediately following the erased item.
  }

  return 0;
}